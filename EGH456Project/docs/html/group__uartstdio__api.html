<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EGH456 Assignment 2: Uartstdio_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EGH456 Assignment 2
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__uartstdio__api.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Uartstdio_api</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa413007c81e82b6d58bbbc9414660eae" id="r_gaa413007c81e82b6d58bbbc9414660eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa413007c81e82b6d58bbbc9414660eae">UARTStdioConfig</a> (uint32_t ui32PortNum, uint32_t ui32Baud, uint32_t ui32SrcClock)</td></tr>
<tr class="separator:gaa413007c81e82b6d58bbbc9414660eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a30a1e04e8b5b7a9cfc07b56040d72" id="r_gaf9a30a1e04e8b5b7a9cfc07b56040d72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9a30a1e04e8b5b7a9cfc07b56040d72">UARTwrite</a> (const char *pcBuf, uint32_t ui32Len)</td></tr>
<tr class="separator:gaf9a30a1e04e8b5b7a9cfc07b56040d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb95fa6af501db544ac635fc6eab80b" id="r_ga3eb95fa6af501db544ac635fc6eab80b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3eb95fa6af501db544ac635fc6eab80b">UARTgets</a> (char *pcBuf, uint32_t ui32Len)</td></tr>
<tr class="separator:ga3eb95fa6af501db544ac635fc6eab80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057774397b6eff0d0fd99f4d9790c9db" id="r_ga057774397b6eff0d0fd99f4d9790c9db"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga057774397b6eff0d0fd99f4d9790c9db">UARTgetc</a> (void)</td></tr>
<tr class="separator:ga057774397b6eff0d0fd99f4d9790c9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df4748a317174f7cf3c20ffc072abb0" id="r_ga9df4748a317174f7cf3c20ffc072abb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9df4748a317174f7cf3c20ffc072abb0">UARTprintf</a> (const char *pcString,...)</td></tr>
<tr class="separator:ga9df4748a317174f7cf3c20ffc072abb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga057774397b6eff0d0fd99f4d9790c9db" name="ga057774397b6eff0d0fd99f4d9790c9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057774397b6eff0d0fd99f4d9790c9db">&#9670;&#160;</a></span>UARTgetc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char UARTgetc </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a single character from the UART, blocking if necessary.</p>
<p>This function will receive a single character from the UART and store it at the supplied address.</p>
<p>In both buffered and unbuffered modes, this function will block until a character is received. If non-blocking operation is required in buffered mode, a call to UARTRxAvail() may be made to determine whether any characters are currently available for reading.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the character read. </dd></dl>

</div>
</div>
<a id="ga3eb95fa6af501db544ac635fc6eab80b" name="ga3eb95fa6af501db544ac635fc6eab80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb95fa6af501db544ac635fc6eab80b">&#9670;&#160;</a></span>UARTgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UARTgets </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>pcBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32Len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple UART based get string function, with some line processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcBuf</td><td>points to a buffer for the incoming string from the UART. </td></tr>
    <tr><td class="paramname">ui32Len</td><td>is the length of the buffer for storage of the string, including the trailing 0.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will receive a string from the UART input and store the characters in the buffer pointed to by <em>pcBuf</em>. The characters will continue to be stored until a termination character is received. The termination characters are CR, LF, or ESC. A CRLF pair is treated as a single termination character. The termination characters are not stored in the string. The string will be terminated with a 0 and the function will return.</p>
<p>In both buffered and unbuffered modes, this function will block until a termination character is received. If non-blocking operation is required in buffered mode, a call to UARTPeek() may be made to determine whether a termination character already exists in the receive buffer prior to calling <a class="el" href="#ga3eb95fa6af501db544ac635fc6eab80b">UARTgets()</a>.</p>
<p>Since the string will be null terminated, the user must ensure that the buffer is sized to allow for the additional null character.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the count of characters that were stored, not including the trailing 0. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__uartstdio__api_ga3eb95fa6af501db544ac635fc6eab80b_cgraph.png" border="0" usemap="#agroup__uartstdio__api_ga3eb95fa6af501db544ac635fc6eab80b_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ga9df4748a317174f7cf3c20ffc072abb0" name="ga9df4748a317174f7cf3c20ffc072abb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df4748a317174f7cf3c20ffc072abb0">&#9670;&#160;</a></span>UARTprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTprintf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pcString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple UART based vprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcString</td><td>is the format string. </td></tr>
    <tr><td class="paramname">vaArgP</td><td>is a variable argument list pointer whose content will depend upon the format string passed in <em>pcString</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>vprintf()</code> function. All of its output will be sent to the UART. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %s, %d, %i, %u, %p, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces ! added to reach eight;</code>%08d'' will use eight characters as well but will ! add zeroes instead of spaces. ! ! The type of the arguments in the variable arguments list must match the ! requirements of the format string. For example, if an integer was passed ! where a string was expected, an error of some kind will most likely occur. ! ! </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>void <a class="el" href="uartstdio_8h.html#ac24c8a911d71d799981ea44353f472de">UARTvprintf(const char *pcString, va_list vaArgP)</a> { uint32_t ui32Idx, ui32Value, ui32Pos, ui32Count, ui32Base, ui32Neg; char *pcStr, pcBuf[16], cFill;</p>
<p>Check the arguments. </p><pre class="fragment">ASSERT(pcString != 0);
</pre><p>Loop while there are more characters in the string. </p><pre class="fragment">while(*pcString)
{
</pre><p>Find the first non-% character, or the end of the string. </p><pre class="fragment">    for(ui32Idx = 0;
        (pcString[ui32Idx] != '%') &amp;&amp; (pcString[ui32Idx] != '\0');
        ui32Idx++)
    {
    }
</pre><p>Write this portion of the string. </p><pre class="fragment">    UARTwrite(pcString, ui32Idx);
</pre><p>Skip the portion of the string that was written. </p><pre class="fragment">    pcString += ui32Idx;
</pre><p>See if the next character is a %. </p><pre class="fragment">    if(*pcString == '%')
    {
</pre><p>Skip the %. </p><pre class="fragment">        pcString++;
</pre><p>Set the digit count to zero, and the fill character to space (in other words, to the defaults). </p><pre class="fragment">        ui32Count = 0;
        cFill = ' ';
</pre><p>It may be necessary to get back here to process more characters. Goto's aren't pretty, but effective. I feel extremely dirty for using not one but two of the beasts.</p>
<p>again:</p>
<p>Determine how to handle the next character. </p><pre class="fragment">        switch(*pcString++)
        {
</pre><p>Handle the digit characters. </p><pre class="fragment">            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
</pre><p>If this is a zero, and it is the first digit, then the fill character is a zero instead of a space. </p><pre class="fragment">                if((pcString[-1] == '0') &amp;&amp; (ui32Count == 0))
                {
                    cFill = '0';
                }
</pre><p>Update the digit count. </p><pre class="fragment">                ui32Count *= 10;
                ui32Count += pcString[-1] - '0';
</pre><p>Get the next character. </p><pre class="fragment">                goto again;
            }
</pre><p>Handle the c command. </p><pre class="fragment">            case 'c':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ui32Value = va_arg(vaArgP, uint32_t);
</pre><p>Print out the character. </p><pre class="fragment">                UARTwrite((char *)&amp;ui32Value, 1);
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle the d and i commands. </p><pre class="fragment">            case 'd':
            case 'i':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ui32Value = va_arg(vaArgP, uint32_t);
</pre><p>Reset the buffer position. </p><pre class="fragment">                ui32Pos = 0;
</pre><p>If the value is negative, make it positive and indicate that a minus sign is needed. </p><pre class="fragment">                if((int32_t)ui32Value &lt; 0)
                {
</pre><p>Make the value positive. </p><pre class="fragment">                    ui32Value = -(int32_t)ui32Value;
</pre><p>Indicate that the value is negative. </p><pre class="fragment">                    ui32Neg = 1;
                }
                else
                {
</pre><p>Indicate that the value is positive so that a minus sign isn't inserted. </p><pre class="fragment">                    ui32Neg = 0;
                }
</pre><p>Set the base to 10. </p><pre class="fragment">                ui32Base = 10;
</pre><p>Convert the value to ASCII. </p><pre class="fragment">                goto convert;
            }
</pre><p>Handle the s command. </p><pre class="fragment">            case 's':
            {
</pre><p>Get the string pointer from the varargs. </p><pre class="fragment">                pcStr = va_arg(vaArgP, char *);
</pre><p>Determine the length of the string. </p><pre class="fragment">                for(ui32Idx = 0; pcStr[ui32Idx] != '\0'; ui32Idx++)
                {
                }
</pre><p>Write the string. </p><pre class="fragment">                UARTwrite(pcStr, ui32Idx);
</pre><p>Write any required padding spaces </p><pre class="fragment">                if(ui32Count &gt; ui32Idx)
                {
                    ui32Count -= ui32Idx;
                    while(ui32Count--)
                    {
                        UARTwrite(" ", 1);
                    }
                }
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle the u command. </p><pre class="fragment">            case 'u':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ui32Value = va_arg(vaArgP, uint32_t);
</pre><p>Reset the buffer position. </p><pre class="fragment">                ui32Pos = 0;
</pre><p>Set the base to 10. </p><pre class="fragment">                ui32Base = 10;
</pre><p>Indicate that the value is positive so that a minus sign isn't inserted. </p><pre class="fragment">                ui32Neg = 0;
</pre><p>Convert the value to ASCII. </p><pre class="fragment">                goto convert;
            }
</pre><p>Handle the x and X commands. Note that they are treated identically; in other words, X will use lower case letters for a-f instead of the upper case letters it should use. We also alias p to x. </p><pre class="fragment">            case 'x':
            case 'X':
            case 'p':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ui32Value = va_arg(vaArgP, uint32_t);
</pre><p>Reset the buffer position. </p><pre class="fragment">                ui32Pos = 0;
</pre><p>Set the base to 16. </p><pre class="fragment">                ui32Base = 16;
</pre><p>Indicate that the value is positive so that a minus sign isn't inserted. </p><pre class="fragment">                ui32Neg = 0;
</pre><p>Determine the number of digits in the string version of the value.</p>
<p>convert: for(ui32Idx = 1; (((ui32Idx * ui32Base) &lt;= ui32Value) &amp;&amp; (((ui32Idx * ui32Base) / ui32Base) == ui32Idx)); ui32Idx *= ui32Base, ui32Count&ndash;) { }</p>
<p>If the value is negative, reduce the count of padding characters needed. </p><pre class="fragment">                if(ui32Neg)
                {
                    ui32Count--;
                }
</pre><p>If the value is negative and the value is padded with zeros, then place the minus sign before the padding. </p><pre class="fragment">                if(ui32Neg &amp;&amp; (cFill == '0'))
                {
</pre><p>Place the minus sign in the output buffer. </p><pre class="fragment">                    pcBuf[ui32Pos++] = '-';
</pre><p>The minus sign has been placed, so turn off the negative flag. </p><pre class="fragment">                    ui32Neg = 0;
                }
</pre><p>Provide additional padding at the beginning of the string conversion if needed. </p><pre class="fragment">                if((ui32Count &gt; 1) &amp;&amp; (ui32Count &lt; 16))
                {
                    for(ui32Count--; ui32Count; ui32Count--)
                    {
                        pcBuf[ui32Pos++] = cFill;
                    }
                }
</pre><p>If the value is negative, then place the minus sign before the number. </p><pre class="fragment">                if(ui32Neg)
                {
</pre><p>Place the minus sign in the output buffer. </p><pre class="fragment">                    pcBuf[ui32Pos++] = '-';
                }
</pre><p>Convert the value into a string. </p><pre class="fragment">                for(; ui32Idx; ui32Idx /= ui32Base)
                {
                    pcBuf[ui32Pos++] =
                        g_pcHex[(ui32Value / ui32Idx) % ui32Base];
                }
</pre><p>Write the string. </p><pre class="fragment">                UARTwrite(pcBuf, ui32Pos);
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle the %% command. </p><pre class="fragment">            case '%':
            {
</pre><p>Simply write a single %. </p><pre class="fragment">                UARTwrite(pcString - 1, 1);
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle all other commands. </p><pre class="fragment">            default:
            {
</pre><p>Indicate an error. </p><pre class="fragment">                UARTwrite("ERROR", 5);
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
        }
    }
}
</pre><p> }</p>
<p>! A simple UART based printf function supporting %c, %d, %p, %s, %u, ! %x, and %X. ! !</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcString</td><td>is the format string. !</td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the ! format string. ! ! This function is very similar to the C library <code>fprintf()</code> function. ! All of its output will be sent to the UART. Only the following formatting ! characters are supported: ! ! - %c to print a character ! - %d or %i to print a decimal value ! - %s to print a string ! - %u to print an unsigned decimal value ! - %x to print a hexadecimal value using lower case letters ! - %X to print a hexadecimal value using lower case letters (not upper case ! letters as would typically be used) ! - %p to print a pointer as a hexadecimal value ! - %% to print out a % character ! ! For %s, %d, %i, %u, %p, %x, and %X, an optional number may reside ! between the % and the format character, which specifies the minimum number ! of characters to use for that value; if preceded by a 0 then the extra ! characters will be filled with zeros instead of spaces. For example, ! <code>\%8d'' will use eight characters to print the decimal value with spaces ! added to reach eight;</code>%08d'' will use eight characters as well but will add zeroes instead of spaces.</td></tr>
  </table>
  </dd>
</dl>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__uartstdio__api_ga9df4748a317174f7cf3c20ffc072abb0_cgraph.png" border="0" usemap="#agroup__uartstdio__api_ga9df4748a317174f7cf3c20ffc072abb0_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__uartstdio__api_ga9df4748a317174f7cf3c20ffc072abb0_icgraph.png" border="0" usemap="#agroup__uartstdio__api_ga9df4748a317174f7cf3c20ffc072abb0_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gaa413007c81e82b6d58bbbc9414660eae" name="gaa413007c81e82b6d58bbbc9414660eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa413007c81e82b6d58bbbc9414660eae">&#9670;&#160;</a></span>UARTStdioConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTStdioConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32PortNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32Baud</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32SrcClock</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether the ring buffer whose pointers and size are provided is full or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Read</td><td>points to the read index for the buffer. </td></tr>
    <tr><td class="paramname">pui32Write</td><td>points to the write index for the buffer. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine whether or not a given ring buffer is full. The structure of the code is specifically to ensure that we do not see warnings from the compiler related to the order of volatile accesses being undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the buffer is full or <b>false</b> otherwise. Determines whether the ring buffer whose pointers and size are provided is empty or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Read</td><td>points to the read index for the buffer. </td></tr>
    <tr><td class="paramname">pui32Write</td><td>points to the write index for the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine whether or not a given ring buffer is empty. The structure of the code is specifically to ensure that we do not see warnings from the compiler related to the order of volatile accesses being undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the buffer is empty or <b>false</b> otherwise. Determines the number of bytes of data contained in a ring buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Read</td><td>points to the read index for the buffer. </td></tr>
    <tr><td class="paramname">pui32Write</td><td>points to the write index for the buffer. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine how many bytes of data a given ring buffer currently contains. The structure of the code is specifically to ensure that we do not see warnings from the compiler related to the order of volatile accesses being undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes of data currently in the buffer. Configures the UART console.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32PortNum</td><td>is the number of UART port to use for the serial console (0-2) </td></tr>
    <tr><td class="paramname">ui32Baud</td><td>is the bit rate that the UART is to be configured to use. </td></tr>
    <tr><td class="paramname">ui32SrcClock</td><td>is the frequency of the source clock for the UART module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will configure the specified serial port to be used as a serial console. The serial parameters are set to the baud rate specified by the <em>ui32Baud</em> parameter and use 8 bit, no parity, and 1 stop bit.</p>
<p>This function must be called prior to using any of the other UART console functions: <a class="el" href="#ga9df4748a317174f7cf3c20ffc072abb0">UARTprintf()</a> or <a class="el" href="#ga3eb95fa6af501db544ac635fc6eab80b">UARTgets()</a>. This function assumes that the caller has previously configured the relevant UART pins for operation as a UART rather than as GPIOs.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf9a30a1e04e8b5b7a9cfc07b56040d72" name="gaf9a30a1e04e8b5b7a9cfc07b56040d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9a30a1e04e8b5b7a9cfc07b56040d72">&#9670;&#160;</a></span>UARTwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UARTwrite </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pcBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32Len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a string of characters to the UART output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcBuf</td><td>points to a buffer containing the string to transmit. </td></tr>
    <tr><td class="paramname">ui32Len</td><td>is the length of the string to transmit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will transmit the string to the UART output. The number of characters transmitted is determined by the <em>ui32Len</em> parameter. This function does no interpretation or translation of any characters. Since the output is sent to a UART, any LF (/n) characters encountered will be replaced with a CRLF pair.</p>
<p>Besides using the <em>ui32Len</em> parameter to stop transmitting the string, if a null character (0) is encountered, then no more characters will be transmitted and the function will return.</p>
<p>In non-buffered mode, this function is blocking and will not return until all the characters have been written to the output FIFO. In buffered mode, the characters are written to the UART transmit buffer and the call returns immediately. If insufficient space remains in the transmit buffer, additional characters are discarded.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the count of characters written. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__uartstdio__api_gaf9a30a1e04e8b5b7a9cfc07b56040d72_icgraph.png" border="0" usemap="#agroup__uartstdio__api_gaf9a30a1e04e8b5b7a9cfc07b56040d72_icgraph" alt=""/></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
