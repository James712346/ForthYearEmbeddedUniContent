<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EGH456 Assignment 2: Ustdlib_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EGH456 Assignment 2
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__ustdlib__api.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Ustdlib_api</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac00744429a775ce4568691fc4f369360" id="r_gac00744429a775ce4568691fc4f369360"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac00744429a775ce4568691fc4f369360">ustrncpy</a> (char *restrict s1, const char *restrict s2, size_t n)</td></tr>
<tr class="separator:gac00744429a775ce4568691fc4f369360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b6644d4db11375176cb8cc8598c4e5" id="r_ga09b6644d4db11375176cb8cc8598c4e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga09b6644d4db11375176cb8cc8598c4e5">usnprintf</a> (char *restrict s, size_t n, const char *restrict format,...)</td></tr>
<tr class="separator:ga09b6644d4db11375176cb8cc8598c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5728f0b62a5c92bc34f0a41c33278c" id="r_ga3a5728f0b62a5c92bc34f0a41c33278c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3a5728f0b62a5c92bc34f0a41c33278c">ulocaltime</a> (time_t timer, struct tm *tm)</td></tr>
<tr class="separator:ga3a5728f0b62a5c92bc34f0a41c33278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf70d2ea7909ed1600710c2113c84907" id="r_gaaf70d2ea7909ed1600710c2113c84907"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf70d2ea7909ed1600710c2113c84907">umktime</a> (struct tm *timeptr)</td></tr>
<tr class="separator:gaaf70d2ea7909ed1600710c2113c84907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6706f6aaf67c3370800e25b6ae1887d" id="r_gaa6706f6aaf67c3370800e25b6ae1887d"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa6706f6aaf67c3370800e25b6ae1887d">ustrtoul</a> (const char *restrict nptr, const char **restrict endptr, int base)</td></tr>
<tr class="separator:gaa6706f6aaf67c3370800e25b6ae1887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1f1d61220c492f777a3f25fd34df3a" id="r_ga7c1f1d61220c492f777a3f25fd34df3a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c1f1d61220c492f777a3f25fd34df3a">ustrtof</a> (const char *nptr, const char **endptr)</td></tr>
<tr class="separator:ga7c1f1d61220c492f777a3f25fd34df3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277a9ccba3eabd09f2214dd508ddae9e" id="r_ga277a9ccba3eabd09f2214dd508ddae9e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga277a9ccba3eabd09f2214dd508ddae9e">ustrlen</a> (const char *s)</td></tr>
<tr class="separator:ga277a9ccba3eabd09f2214dd508ddae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb47869995960c31c95f08a400882e3f" id="r_gadb47869995960c31c95f08a400882e3f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadb47869995960c31c95f08a400882e3f">ustrstr</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:gadb47869995960c31c95f08a400882e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0085d1d81c8d1570a12a02d3b6ffface" id="r_ga0085d1d81c8d1570a12a02d3b6ffface"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0085d1d81c8d1570a12a02d3b6ffface">ustrncasecmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr class="separator:ga0085d1d81c8d1570a12a02d3b6ffface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9ef59ae11aae4f0169fb3dab34d2d6" id="r_gacb9ef59ae11aae4f0169fb3dab34d2d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb9ef59ae11aae4f0169fb3dab34d2d6">ustrcasecmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:gacb9ef59ae11aae4f0169fb3dab34d2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21ed7429e68621153a72a7230a6a077" id="r_gad21ed7429e68621153a72a7230a6a077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad21ed7429e68621153a72a7230a6a077">ustrncmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr class="separator:gad21ed7429e68621153a72a7230a6a077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3790eee84161a4ea17657fe464e8ab" id="r_gaee3790eee84161a4ea17657fe464e8ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee3790eee84161a4ea17657fe464e8ab">ustrcmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:gaee3790eee84161a4ea17657fe464e8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecc415a64e9bc2cce10f03eb7a6b753" id="r_gaaecc415a64e9bc2cce10f03eb7a6b753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaecc415a64e9bc2cce10f03eb7a6b753">usrand</a> (unsigned int seed)</td></tr>
<tr class="separator:gaaecc415a64e9bc2cce10f03eb7a6b753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04408b1c80a2190c4aad7b783b5af8d8" id="r_ga04408b1c80a2190c4aad7b783b5af8d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04408b1c80a2190c4aad7b783b5af8d8">urand</a> (void)</td></tr>
<tr class="separator:ga04408b1c80a2190c4aad7b783b5af8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3a5728f0b62a5c92bc34f0a41c33278c" name="ga3a5728f0b62a5c92bc34f0a41c33278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a5728f0b62a5c92bc34f0a41c33278c">&#9670;&#160;</a></span>ulocaltime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ulocaltime </td>
          <td>(</td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>timer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *</td>          <td class="paramname"><span class="paramname"><em>tm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts from seconds to calendar date and time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the number of seconds. </td></tr>
    <tr><td class="paramname">tm</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch) into the equivalent month, day, year, hours, minutes, and seconds representation.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga3a5728f0b62a5c92bc34f0a41c33278c_icgraph.png" border="0" usemap="#agroup__ustdlib__api_ga3a5728f0b62a5c92bc34f0a41c33278c_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gaaf70d2ea7909ed1600710c2113c84907" name="gaaf70d2ea7909ed1600710c2113c84907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf70d2ea7909ed1600710c2113c84907">&#9670;&#160;</a></span>umktime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t umktime </td>
          <td>(</td>
          <td class="paramtype">struct tm *</td>          <td class="paramname"><span class="paramname"><em>timeptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts calendar date and time to seconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts the date and time represented by the <em>timeptr</em> structure pointer to the number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch).</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the calendar time and date as seconds. If the conversion was not possible then the function returns (uint32_t)(-1). </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gaaf70d2ea7909ed1600710c2113c84907_cgraph.png" border="0" usemap="#agroup__ustdlib__api_gaaf70d2ea7909ed1600710c2113c84907_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ga04408b1c80a2190c4aad7b783b5af8d8" name="ga04408b1c80a2190c4aad7b783b5af8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04408b1c80a2190c4aad7b783b5af8d8">&#9670;&#160;</a></span>urand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int urand </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a new (pseudo) random number</p>
<p>This function is very similar to the C library <code>rand()</code> function. It will generate a pseudo-random number sequence based on the seed value.</p>
<dl class="section return"><dt>Returns</dt><dd>A pseudo-random number will be returned. </dd></dl>

</div>
</div>
<a id="ga09b6644d4db11375176cb8cc8598c4e5" name="ga09b6644d4db11375176cb8cc8598c4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b6644d4db11375176cb8cc8598c4e5">&#9670;&#160;</a></span>usnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usnprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple vsnprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">arg</td><td>is the list of optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>vsnprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces ! added to reach eight;</code>%08d'' will use eight characters as well but will ! add zeroes instead of spaces. ! ! The type of the arguments after <em>format</em> must match the requirements of ! the format string. For example, if an integer was passed where a string ! was expected, an error of some kind will most likely occur. ! ! The <em>n</em> parameter limits the number of characters that will be ! stored in the buffer pointed to by <em>s</em> to prevent the possibility of ! a buffer overflow. The buffer size should be large enough to hold the ! expected converted output string, including the null termination character. ! ! The function will return the number of characters that would be converted ! as if there were no limit on the buffer size. Therefore it is possible for ! the function to return a count that is greater than the specified buffer ! size. If this happens, it means that the output was truncated. ! ! </p><dl class="section return"><dt>Returns</dt><dd>Returns the number of characters that were to be stored, not ! including the NULL termination character, regardless of space in the ! buffer.</dd></dl>
<p>int uvsnprintf(char * restrict s, size_t n, const char * restrict format,
           va_list arg) { unsigned long ulIdx, ulValue, ulCount, ulBase, ulNeg; char *pcStr, cFill; int iConvertCount = 0;</p>
<p>Check the arguments. </p><pre class="fragment">ASSERT(s);
ASSERT(n);
ASSERT(format);
</pre><p>Adjust buffer size limit to allow one space for null termination. </p><pre class="fragment">if(n)
{
    n--;
}
</pre><p>Initialize the count of characters converted. </p><pre class="fragment">iConvertCount = 0;
</pre><p>Loop while there are more characters in the format string. </p><pre class="fragment">while(*format)
{
</pre><p>Find the first non-% character, or the end of the string. </p><pre class="fragment">    for(ulIdx = 0; (format[ulIdx] != '%') &amp;&amp; (format[ulIdx] != '\0');
        ulIdx++)
    {
    }
</pre><p>Write this portion of the string to the output buffer. If there are more characters to write than there is space in the buffer, then only write as much as will fit in the buffer. </p><pre class="fragment">    if(ulIdx &gt; n)
    {
        ustrncpy(s, format, n);
        s += n;
        n = 0;
    }
    else
    {
        ustrncpy(s, format, ulIdx);
        s += ulIdx;
        n -= ulIdx;
    }
</pre><p>Update the conversion count. This will be the number of characters that should have been written, even if there was not room in the buffer. </p><pre class="fragment">    iConvertCount += ulIdx;
</pre><p>Skip the portion of the format string that was written. </p><pre class="fragment">    format += ulIdx;
</pre><p>See if the next character is a %. </p><pre class="fragment">    if(*format == '%')
    {
</pre><p>Skip the %. </p><pre class="fragment">        format++;
</pre><p>Set the digit count to zero, and the fill character to space (that is, to the defaults). </p><pre class="fragment">        ulCount = 0;
        cFill = ' ';
</pre><p>It may be necessary to get back here to process more characters. Goto's aren't pretty, but effective. I feel extremely dirty for using not one but two of the beasts.</p>
<p>again:</p>
<p>Determine how to handle the next character. </p><pre class="fragment">        switch(*format++)
        {
</pre><p>Handle the digit characters. </p><pre class="fragment">            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
</pre><p>If this is a zero, and it is the first digit, then the fill character is a zero instead of a space. </p><pre class="fragment">                if((format[-1] == '0') &amp;&amp; (ulCount == 0))
                {
                    cFill = '0';
                }
</pre><p>Update the digit count. </p><pre class="fragment">                ulCount *= 10;
                ulCount += format[-1] - '0';
</pre><p>Get the next character. </p><pre class="fragment">                goto again;
            }
</pre><p>Handle the c command. </p><pre class="fragment">            case 'c':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ulValue = va_arg(arg, unsigned long);
</pre><p>Copy the character to the output buffer, if there is room. Update the buffer size remaining. </p><pre class="fragment">                if(n != 0)
                {
                     s++ = (char)ulValue;
                    n--;
                }
</pre><p>Update the conversion count. </p><pre class="fragment">                iConvertCount++;
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle the d and i commands. </p><pre class="fragment">            case 'd':
            case 'i':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ulValue = va_arg(arg, unsigned long);
</pre><p>If the value is negative, make it positive and indicate that a minus sign is needed. </p><pre class="fragment">                if((long)ulValue &lt; 0)
                {
</pre><p>Make the value positive. </p><pre class="fragment">                    ulValue = -(long)ulValue;
</pre><p>Indicate that the value is negative. </p><pre class="fragment">                    ulNeg = 1;
                }
                else
                {
</pre><p>Indicate that the value is positive so that a negative sign isn't inserted. </p><pre class="fragment">                    ulNeg = 0;
                }
</pre><p>Set the base to 10. </p><pre class="fragment">                ulBase = 10;
</pre><p>Convert the value to ASCII. </p><pre class="fragment">                goto convert;
            }
</pre><p>Handle the s command. </p><pre class="fragment">            case 's':
            {
</pre><p>Get the string pointer from the varargs. </p><pre class="fragment">                pcStr = va_arg(arg, char *);
</pre><p>Determine the length of the string. </p><pre class="fragment">                for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
                {
                }
</pre><p>Update the convert count to include any padding that should be necessary (regardless of whether we have space to write it or not). </p><pre class="fragment">                if(ulCount &gt; ulIdx)
                {
                    iConvertCount += (ulCount - ulIdx);
                }
</pre><p>Copy the string to the output buffer. Only copy as much as will fit in the buffer. Update the output buffer pointer and the space remaining. </p><pre class="fragment">                if(ulIdx &gt; n)
                {
                    ustrncpy(s, pcStr, n);
                    s += n;
                    n = 0;
                }
                else
                {
                    ustrncpy(s, pcStr, ulIdx);
                    s += ulIdx;
                    n -= ulIdx;
</pre><p>Write any required padding spaces assuming there is still space in the buffer. </p><pre class="fragment">                    if(ulCount &gt; ulIdx)
                    {
                        ulCount -= ulIdx;
                        if(ulCount &gt; n)
                        {
                            ulCount = n;
                        }
                        n = -ulCount;

                        while(ulCount--)
                        {
                             s++ = ' ';
                        }
                    }
                }
</pre><p>Update the conversion count. This will be the number of characters that should have been written, even if there was not room in the buffer. </p><pre class="fragment">                iConvertCount += ulIdx;
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle the u command. </p><pre class="fragment">            case 'u':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ulValue = va_arg(arg, unsigned long);
</pre><p>Set the base to 10. </p><pre class="fragment">                ulBase = 10;
</pre><p>Indicate that the value is positive so that a minus sign isn't inserted. </p><pre class="fragment">                ulNeg = 0;
</pre><p>Convert the value to ASCII. </p><pre class="fragment">                goto convert;
            }
</pre><p>Handle the x and X commands. Note that they are treated identically; that is, X will use lower case letters for a-f instead of the upper case letters is should use. We also alias p to x. </p><pre class="fragment">            case 'x':
            case 'X':
            case 'p':
            {
</pre><p>Get the value from the varargs. </p><pre class="fragment">                ulValue = va_arg(arg, unsigned long);
</pre><p>Set the base to 16. </p><pre class="fragment">                ulBase = 16;
</pre><p>Indicate that the value is positive so that a minus sign isn't inserted. </p><pre class="fragment">                ulNeg = 0;
</pre><p>Determine the number of digits in the string version of the value.</p>
<p>convert: for(ulIdx = 1; (((ulIdx * ulBase) &lt;= ulValue) &amp;&amp; (((ulIdx * ulBase) / ulBase) == ulIdx)); ulIdx *= ulBase, ulCount&ndash;) { }</p>
<p>If the value is negative, reduce the count of padding characters needed. </p><pre class="fragment">                if(ulNeg)
                {
                    ulCount--;
                }
</pre><p>If the value is negative and the value is padded with zeros, then place the minus sign before the padding. </p><pre class="fragment">                if(ulNeg &amp;&amp; (n != 0) &amp;&amp; (cFill == '0'))
                {
</pre><p>Place the minus sign in the output buffer. </p><pre class="fragment">                     s++ = '-';
                    n--;
</pre><p>Update the conversion count. </p><pre class="fragment">                    iConvertCount++;
</pre><p>The minus sign has been placed, so turn off the negative flag. </p><pre class="fragment">                    ulNeg = 0;
                }
</pre><p>See if there are more characters in the specified field width than there are in the conversion of this value. </p><pre class="fragment">                if((ulCount &gt; 1) &amp;&amp; (ulCount &lt; 65536))
                {
</pre><p>Loop through the required padding characters. </p><pre class="fragment">                    for(ulCount--; ulCount; ulCount--)
                    {
</pre><p>Copy the character to the output buffer if there is room. </p><pre class="fragment">                        if(n != 0)
                        {
                             s++ = cFill;
                            n--;
                        }
</pre><p>Update the conversion count. </p><pre class="fragment">                        iConvertCount++;
                    }
                }
</pre><p>If the value is negative, then place the minus sign before the number. </p><pre class="fragment">                if(ulNeg &amp;&amp; (n != 0))
                {
</pre><p>Place the minus sign in the output buffer. </p><pre class="fragment">                     s++ = '-';
                    n--;
</pre><p>Update the conversion count. </p><pre class="fragment">                    iConvertCount++;
                }
</pre><p>Convert the value into a string. </p><pre class="fragment">                for(; ulIdx; ulIdx /= ulBase)
                {
</pre><p>Copy the character to the output buffer if there is room. </p><pre class="fragment">                    if(n != 0)
                    {
                         s++ = g_pcHex[(ulValue / ulIdx) % ulBase];
                        n--;
                    }
</pre><p>Update the conversion count. </p><pre class="fragment">                    iConvertCount++;
                }
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle the %% command. </p><pre class="fragment">            case '%':
            {
</pre><p>Simply write a single %. </p><pre class="fragment">                if(n != 0)
                {
                     s++ = format[-1];
                    n--;
                }
</pre><p>Update the conversion count. </p><pre class="fragment">                iConvertCount++;
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
</pre><p>Handle all other commands. </p><pre class="fragment">            default:
            {
</pre><p>Indicate an error. </p><pre class="fragment">                if(n &gt;= 5)
                {
                    ustrncpy(s, "ERROR", 5);
                    s += 5;
                    n -= 5;
                }
                else
                {
                    ustrncpy(s, "ERROR", n);
                    s += n;
                    n = 0;
                }
</pre><p>Update the conversion count. </p><pre class="fragment">                iConvertCount += 5;
</pre><p>This command has been handled. </p><pre class="fragment">                break;
            }
        }
    }
}
</pre><p>Null terminate the string in the buffer. </p><pre class="fragment"> s = 0;
</pre><p>Return the number of characters in the full converted string. </p><pre class="fragment">return(iConvertCount);
</pre><p> }</p>
<p>! A simple sprintf function supporting %c, %d, %p, %s, %u, %x, and %X. ! !</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the buffer where the converted string is stored. !</td></tr>
    <tr><td class="paramname">format</td><td>is the format string. !</td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the ! format string. ! ! This function is very similar to the C library <code>sprintf()</code> function. ! Only the following formatting characters are supported: ! ! - %c to print a character ! - %d or %i to print a decimal value ! - %s to print a string ! - %u to print an unsigned decimal value ! - %x to print a hexadecimal value using lower case letters ! - %X to print a hexadecimal value using lower case letters (not upper case ! letters as would typically be used) ! - %p to print a pointer as a hexadecimal value ! - %% to print out a % character ! ! For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside ! between the % and the format character, which specifies the minimum number ! of characters to use for that value; if preceded by a 0 then the extra ! characters will be filled with zeros instead of spaces. For example, ! <code>\%8d'' will use eight characters to print the decimal value with spaces ! added to reach eight;</code>%08d'' will use eight characters as well but will ! add zeros instead of spaces. ! ! The type of the arguments after <em>format</em> must match the requirements of ! the format string. For example, if an integer was passed where a string ! was expected, an error of some kind will most likely occur. ! ! The caller must ensure that the buffer <em>s</em> is large enough to hold the ! entire converted string, including the null termination character. ! ! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the count of characters that were written to the output ! buffer, not including the NULL termination character.</dd></dl>
<p>int usprintf(char * restrict s, const char * restrict format, ...) { va_list arg; int ret;</p>
<p>Start the varargs processing. </p><pre class="fragment">va_start(arg, format);
</pre><p>Call vsnprintf to perform the conversion. Use a large number for the buffer size. </p><pre class="fragment">ret = uvsnprintf(s, 0xffff, format, arg);
</pre><p>End the varargs processing. </p><pre class="fragment">va_end(arg);
</pre><p>Return the conversion count. </p><pre class="fragment">return(ret);
</pre><p> }</p>
<p>! A simple snprintf function supporting %c, %d, %p, %s, %u, %x, and ! %X. ! !</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the buffer where the converted string is stored. !</td></tr>
    <tr><td class="paramname">n</td><td>is the size of the buffer. !</td></tr>
    <tr><td class="paramname">format</td><td>is the format string. !</td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the ! format string. ! ! This function is very similar to the C library <code>sprintf()</code> function. ! Only the following formatting characters are supported: ! ! - %c to print a character ! - %d or %i to print a decimal value ! - %s to print a string ! - %u to print an unsigned decimal value ! - %x to print a hexadecimal value using lower case letters ! - %X to print a hexadecimal value using lower case letters (not upper case ! letters as would typically be used) ! - %p to print a pointer as a hexadecimal value ! - %% to print out a % character ! ! For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside ! between the % and the format character, which specifies the minimum number ! of characters to use for that value; if preceded by a 0 then the extra ! characters will be filled with zeros instead of spaces. For example, ! <code>\%8d'' will use eight characters to print the decimal value with spaces ! added to reach eight;</code>%08d'' will use eight characters as well but will add zeros instead of spaces.</td></tr>
  </table>
  </dd>
</dl>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The function will copy at most <em>n</em> - 1 characters into the buffer <em>s</em>. One space is reserved in the buffer for the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga09b6644d4db11375176cb8cc8598c4e5_icgraph.png" border="0" usemap="#agroup__ustdlib__api_ga09b6644d4db11375176cb8cc8598c4e5_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gaaecc415a64e9bc2cce10f03eb7a6b753" name="gaaecc415a64e9bc2cce10f03eb7a6b753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaecc415a64e9bc2cce10f03eb7a6b753">&#9670;&#160;</a></span>usrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usrand </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the random number generator seed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>is the new seed value to use for the random number generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>srand()</code> function. It will set the seed value used in the <code><a class="el" href="#ga04408b1c80a2190c4aad7b783b5af8d8">urand()</a></code> function.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gacb9ef59ae11aae4f0169fb3dab34d2d6" name="gacb9ef59ae11aae4f0169fb3dab34d2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9ef59ae11aae4f0169fb3dab34d2d6">&#9670;&#160;</a></span>ustrcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcasecmp()</code> function. It compares two strings without regard to case. The comparison ends if a terminating NULL character is found in either string. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gacb9ef59ae11aae4f0169fb3dab34d2d6_cgraph.png" border="0" usemap="#agroup__ustdlib__api_gacb9ef59ae11aae4f0169fb3dab34d2d6_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gaee3790eee84161a4ea17657fe464e8ab" name="gaee3790eee84161a4ea17657fe464e8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3790eee84161a4ea17657fe464e8ab">&#9670;&#160;</a></span>ustrcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrcmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcmp()</code> function. It compares two strings, taking case into account. The comparison ends if a terminating NULL character is found in either string. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gaee3790eee84161a4ea17657fe464e8ab_cgraph.png" border="0" usemap="#agroup__ustdlib__api_gaee3790eee84161a4ea17657fe464e8ab_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ga277a9ccba3eabd09f2214dd508ddae9e" name="ga277a9ccba3eabd09f2214dd508ddae9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga277a9ccba3eabd09f2214dd508ddae9e">&#9670;&#160;</a></span>ustrlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ustrlen </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of a null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is a pointer to the string whose length is to be found.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strlen()</code> function. It determines the length of the null-terminated string passed and returns this to the caller.</p>
<p>This implementation assumes that single byte character strings are passed and will return incorrect values if passed some UTF-8 strings.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the string pointed to by <em>s</em>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga277a9ccba3eabd09f2214dd508ddae9e_icgraph.png" border="0" usemap="#agroup__ustdlib__api_ga277a9ccba3eabd09f2214dd508ddae9e_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ga0085d1d81c8d1570a12a02d3b6ffface" name="ga0085d1d81c8d1570a12a02d3b6ffface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0085d1d81c8d1570a12a02d3b6ffface">&#9670;&#160;</a></span>ustrncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">n</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncasecmp()</code> function. It compares at most <em>n</em> characters of two strings without regard to case. The comparison ends if a terminating NULL character is found in either string before <em>n</em> characters are compared. In this case, the shorter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga0085d1d81c8d1570a12a02d3b6ffface_icgraph.png" border="0" usemap="#agroup__ustdlib__api_ga0085d1d81c8d1570a12a02d3b6ffface_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gad21ed7429e68621153a72a7230a6a077" name="gad21ed7429e68621153a72a7230a6a077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad21ed7429e68621153a72a7230a6a077">&#9670;&#160;</a></span>ustrncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrncmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">n</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncmp()</code> function. It compares at most <em>n</em> characters of two strings taking case into account. The comparison ends if a terminating NULL character is found in either string before <em>n</em> characters are compared. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gad21ed7429e68621153a72a7230a6a077_icgraph.png" border="0" usemap="#agroup__ustdlib__api_gad21ed7429e68621153a72a7230a6a077_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gac00744429a775ce4568691fc4f369360" name="gac00744429a775ce4568691fc4f369360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00744429a775ce4568691fc4f369360">&#9670;&#160;</a></span>ustrncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ustrncpy </td>
          <td>(</td>
          <td class="paramtype">char *restrict</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a certain number of characters from one string to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>is a pointer to the destination buffer into which characters are to be copied. </td></tr>
    <tr><td class="paramname">s2</td><td>is a pointer to the string from which characters are to be copied. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of characters to copy to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies at most <em>n</em> characters from the string pointed to by <em>s2</em> into the buffer pointed to by <em>s1</em>. If the end of <em>s2</em> is found before <em>n</em> characters have been copied, remaining characters in <em>s1</em> will be padded with zeroes until <em>n</em> characters have been written. Note that the destination string will only be NULL terminated if the number of characters to be copied is greater than the length of <em>s2</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>s1</em>. </dd></dl>

</div>
</div>
<a id="gadb47869995960c31c95f08a400882e3f" name="gadb47869995960c31c95f08a400882e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb47869995960c31c95f08a400882e3f">&#9670;&#160;</a></span>ustrstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ustrstr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a substring within a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>is a pointer to the string that will be searched. </td></tr>
    <tr><td class="paramname">s2</td><td>is a pointer to the substring that is to be found within <em>s1</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strstr()</code> function. It scans a string for the first instance of a given substring and returns a pointer to that substring. If the substring cannot be found, a NULL pointer is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the first occurrence of <em>s2</em> within <em>s1</em> or NULL if no match is found. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gadb47869995960c31c95f08a400882e3f_cgraph.png" border="0" usemap="#agroup__ustdlib__api_gadb47869995960c31c95f08a400882e3f_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ga7c1f1d61220c492f777a3f25fd34df3a" name="ga7c1f1d61220c492f777a3f25fd34df3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1f1d61220c492f777a3f25fd34df3a">&#9670;&#160;</a></span>ustrtof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ustrtof </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a string into its floating-point equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>is a pointer to the string containing the floating-point value. </td></tr>
    <tr><td class="paramname">endptr</td><td>is a pointer that will be set to the first character past the floating-point value in the string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtof()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into a floating-point value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the conversion. </dd></dl>

</div>
</div>
<a id="gaa6706f6aaf67c3370800e25b6ae1887d" name="gaa6706f6aaf67c3370800e25b6ae1887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6706f6aaf67c3370800e25b6ae1887d">&#9670;&#160;</a></span>ustrtoul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ustrtoul </td>
          <td>(</td>
          <td class="paramtype">const char *restrict</td>          <td class="paramname"><span class="paramname"><em>nptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **restrict</td>          <td class="paramname"><span class="paramname"><em>endptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a string into its numeric equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>is a pointer to the string containing the integer. </td></tr>
    <tr><td class="paramname">endptr</td><td>is a pointer that will be set to the first character past the integer in the string. </td></tr>
    <tr><td class="paramname">base</td><td>is the radix to use for the conversion; can be zero to auto-select the radix or between 2 and 16 to explicitly specify the radix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtoul()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into an integer value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the conversion. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
